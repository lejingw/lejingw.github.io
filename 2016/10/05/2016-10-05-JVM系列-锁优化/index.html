<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>JVM系列-锁优化 · lejingw's blog</title><meta name="description" content="适应性自旋(Adaptive Spinning)互斥同步对性能最大的影响是阻塞的实现, 挂起线程和恢复线程的操作都需要转入内核态中完成, 该并发性能带来很大的压力.   短暂的等待, 并不放弃CPU的执行时间. 使用-XX:+UseSpinning 参数开启(jdk1.6后默认开启), 使用-XX:"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Typography</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">活版印字</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">대문</a></li><li><a href="/archives">아카이브</a></li><li><a href="/categories">카테고리</a></li><li><a href="/tags">태그</a></li><li class="soc"><a href="https://lejingw.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2020&nbsp;<a target="_blank" href="https://lejingw.github.io" rel="noopener noreferrer">lejingw</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>JVM系列-锁优化</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2016-10-05</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a href="/categories/technology/" title="technology" class="a-tag">technology</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/jvm/" title="jvm" class="a-tag">jvm</a><span>&nbsp;</span></span></p><p class="post-abstract"><h2 id="适应性自旋-Adaptive-Spinning"><a href="#适应性自旋-Adaptive-Spinning" class="headerlink" title="适应性自旋(Adaptive Spinning)"></a>适应性自旋(Adaptive Spinning)</h2><p>互斥同步对性能最大的影响是阻塞的实现, 挂起线程和恢复线程的操作都需要转入内核态中完成, 该并发性能带来很大的压力.   短暂的等待, 并不放弃CPU的执行时间. 使用<code>-XX:+UseSpinning</code> 参数开启(jdk1.6后默认开启), 使用<code>-XX:PreBlockSpin</code>来设置自旋的次数(默认10次).</p>
<p>自适应自旋:由前一次在同一个锁上的自旋时间及锁的拥有者状态来决定.</p>
<h2 id="锁消除-Lock-Elimination"><a href="#锁消除-Lock-Elimination" class="headerlink" title="锁消除(Lock Elimination)"></a>锁消除(Lock Elimination)</h2><p>根据逃逸分析,判断一段代码中, 堆上的所有数据都不会逃逸出去从而被其他线程访问到, 则任务是线程私有的, 同步加锁无需进行.</p>
<pre><code>public String appendStr(String a, String b, String c)&#123;
    return a+b+c;
&#125;
===&gt;
public String appendStr(String a, String b, String c)&#123;
    StringBuffer sb = new StringBuffer(a);
    sb.append(b).append(c);
    return sb.toString();
&#125;</code></pre>
<h2 id="锁粗化-Lock-Coarsening"><a href="#锁粗化-Lock-Coarsening" class="headerlink" title="锁粗化(Lock Coarsening)"></a>锁粗化(Lock Coarsening)</h2><p>一系列连续的操作对同一个对象反复的加锁解锁,甚至加锁操作出现在循环体中, 频繁的互斥同步操作导致不必要的性能损耗.</p>
<h2 id="轻量级锁-Lightweight-Locking"><a href="#轻量级锁-Lightweight-Locking" class="headerlink" title="轻量级锁(Lightweight Locking)"></a>轻量级锁(Lightweight Locking)</h2><p>对象头包含两/三部分:</p>
<ul>
<li>Mark World<ul>
<li>HashCode</li>
<li>GC分代年龄(Generational<br>GC Age)等</li>
</ul>
</li>
<li>指向方法去对象类型数据的指针</li>
<li>数组长度(数组类型独有)</li>
</ul>
<table>
<thead>
<tr>
<th>存储内容</th>
<th align="center">标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>对象哈希码、对象分代年龄</td>
<td align="center">01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向锁记录的指针</td>
<td align="center">00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td align="center">10</td>
<td>膨胀(重量级锁定)</td>
</tr>
<tr>
<td>空，不需要记录信息</td>
<td align="center">11</td>
<td>GC标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td align="center">01</td>
<td>可偏向</td>
</tr>
</tbody></table>
<h2 id="偏向锁-Biased-Locking"><a href="#偏向锁-Biased-Locking" class="headerlink" title="偏向锁(Biased Locking)"></a>偏向锁(Biased Locking)</h2><blockquote>
<p>理由依据:”绝大部分的锁,在整个同步周期内都是不存在竞争的”. 如果没有竞争, 轻量级锁使用CAS操作避免了使用互斥量的开销,但如果存在锁竞争,除了互斥量的开销外,还额外发了CAS操作, <strong><em>因此在有竞争的情况下,轻量级锁比传统的重量级锁更慢</em></strong></p>
</blockquote>
<blockquote>
<p><strong><em>偏向锁可以提高带有同步但无竞争的程序性能</em></strong>, 如果程序中大多数的锁总是被多个不同的线程访问,那偏向模式就是多余的. 可以通过<code>-XX:-UseBiasedLocking</code>(JDK1.6默认开启)禁用偏向锁优化来提高性能.</p>
</blockquote>
</p></div><div class="share"><span>공유하기</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a target="_blank" rel="noopener" href="http://twitter.com/home?status=https://lejingw.github.io/2016/10/05/2016-10-05-JVM系列-锁优化/%20lejingw's blog%20JVM系列-锁优化" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2016/10/08/2016-10-08-JVM%E7%B3%BB%E5%88%97-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" title="JVM系列-字节码执行引擎"><i class="fa fa-angle-double-left"></i>&nbsp;이전 포스트: JVM系列-字节码执行引擎</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2016/09/30/2016-09-30-JVM%E7%B3%BB%E5%88%97-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" title="JVM系列-内存分配">다음 포스트: JVM系列-内存分配&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2020&nbsp;<a target="_blank" href="https://lejingw.github.io" rel="noopener noreferrer">lejingw</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>